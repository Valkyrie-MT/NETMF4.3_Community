//---------------------------------------------------------------------------
//
// Copyright 2010 Stanislav "CW" Simicek
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//---------------------------------------------------------------------------
//
// This file was generated by a tool, but manually edited to fix the problems
// in the generated code. Also, function arguments validation and checking if
// the object was disposed is done here, mainly because of the availability
// of convenient TINYCLR_XXX macros.
//

#include "CW_NETMF_OneWire.h"
#include "CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire.h"

using namespace CW::NETMF::Hardware;

/////////////////////////////////////////////////////////////////////////////
// Validation Helpers

HRESULT Library_CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire::CheckBufferArguments(
  CLR_RT_TypedArray_UINT8 buffer, INT32 index, INT32& refCount)
{
  // TODO: Move marshaling code here (DRY)
  if(index < 0)
  {
    return CLR_E_OUT_OF_RANGE;  // ArgumentOutOfRangeException
  }
  if(refCount == -1)
  {
    // Special case to save buffer.Length accessor call (the buffer is usually
    // read/written from 'index' to the end), and to allow optional parameters.
    refCount = buffer.GetSize() - index;
  }
  if(refCount < 0)
  {
    return CLR_E_OUT_OF_RANGE;  // ArgumentOutOfRangeException
  }
  if((buffer.GetSize() - index) < refCount)
  {
    return CLR_E_INVALID_PARAMETER; // ArgumentException
  }
  return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Interop

HRESULT Library_CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire::_ctor___VOID__MicrosoftSPOTHardwareMicrosoftSPOTHardwareCpuPin(CLR_RT_StackFrame& stack)
{
  TINYCLR_HEADER(); hr = S_OK;
  {
    CLR_RT_HeapBlock* pMngObj = Interop_Marshal_RetrieveManagedObject(stack);
    FAULT_ON_NULL(pMngObj);

    UINT32 portId;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_UINT32(stack, 1, portId));

    OneWire::_ctor(pMngObj, portId, hr);
    TINYCLR_CHECK_HRESULT(hr);
  }
  TINYCLR_NOCLEANUP();
}

HRESULT Library_CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire::Reset___BOOLEAN(CLR_RT_StackFrame& stack)
{
  TINYCLR_HEADER(); hr = S_OK;
  {
    CLR_RT_HeapBlock* pMngObj = Interop_Marshal_RetrieveManagedObject(stack);
    FAULT_ON_NULL(pMngObj);

    if(OneWire::Get_disposed(pMngObj))
    {
      TINYCLR_SET_AND_LEAVE(CLR_E_OBJECT_DISPOSED);
    }

    INT8 retVal = OneWire::Reset(pMngObj,  hr);
    TINYCLR_CHECK_HRESULT(hr);
    SetResult_INT8(stack, retVal);
  }
  TINYCLR_NOCLEANUP();
}

HRESULT Library_CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire::Read___I4__SZARRAY_U1__I4__I4(CLR_RT_StackFrame& stack)
{
  TINYCLR_HEADER(); hr = S_OK;
  {
    CLR_RT_HeapBlock* pMngObj = Interop_Marshal_RetrieveManagedObject(stack);
    FAULT_ON_NULL(pMngObj);

    if(OneWire::Get_disposed(pMngObj))
    {
      TINYCLR_SET_AND_LEAVE(CLR_E_OBJECT_DISPOSED);
    }

    CLR_RT_TypedArray_UINT8 buffer;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_UINT8_ARRAY(stack, 1, buffer));

    INT32 index;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_INT32(stack, 2, index));

    INT32 count;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_INT32(stack, 3, count));

    // Validate buffer arguments (may change count if == -1)
    TINYCLR_CHECK_HRESULT(CheckBufferArguments(buffer, index, count));

    INT32 retVal = OneWire::Read(pMngObj, buffer, index, count, hr);
    TINYCLR_CHECK_HRESULT(hr);
    SetResult_INT32(stack, retVal);
  }
  TINYCLR_NOCLEANUP();
}

HRESULT Library_CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire::ReadBit___U1(CLR_RT_StackFrame& stack)
{
  TINYCLR_HEADER(); hr = S_OK;
  {
    CLR_RT_HeapBlock* pMngObj = Interop_Marshal_RetrieveManagedObject(stack);
    FAULT_ON_NULL(pMngObj);

    if(OneWire::Get_disposed(pMngObj))
    {
      TINYCLR_SET_AND_LEAVE(CLR_E_OBJECT_DISPOSED);
    }

    UINT8 retVal = OneWire::ReadBit(pMngObj, hr);
    TINYCLR_CHECK_HRESULT(hr);
    SetResult_UINT8(stack, retVal);
  }
  TINYCLR_NOCLEANUP();
}

HRESULT Library_CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire::ReadByte___U1(CLR_RT_StackFrame& stack)
{
  TINYCLR_HEADER(); hr = S_OK;
  {
    CLR_RT_HeapBlock* pMngObj = Interop_Marshal_RetrieveManagedObject(stack);
    FAULT_ON_NULL(pMngObj);

    if(OneWire::Get_disposed(pMngObj))
    {
      TINYCLR_SET_AND_LEAVE(CLR_E_OBJECT_DISPOSED);
    }

    UINT8 retVal = OneWire::ReadByte(pMngObj,  hr);
    TINYCLR_CHECK_HRESULT(hr);
    SetResult_UINT8(stack, retVal);
  }
  TINYCLR_NOCLEANUP();
}

HRESULT Library_CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire::Write___VOID__SZARRAY_U1__I4__I4(CLR_RT_StackFrame& stack)
{
  TINYCLR_HEADER(); hr = S_OK;
  {
    CLR_RT_HeapBlock* pMngObj = Interop_Marshal_RetrieveManagedObject(stack);
    FAULT_ON_NULL(pMngObj);

    if(OneWire::Get_disposed(pMngObj))
    {
      TINYCLR_SET_AND_LEAVE(CLR_E_OBJECT_DISPOSED);
    }

    CLR_RT_TypedArray_UINT8 buffer;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_UINT8_ARRAY(stack, 1, buffer));

    INT32 index;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_INT32(stack, 2, index));

    INT32 count;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_INT32(stack, 3, count));

    // Validate buffer arguments (may change count if == -1)
    TINYCLR_CHECK_HRESULT(CheckBufferArguments(buffer, index, count));

    OneWire::Write(pMngObj, buffer, index, count, hr);
    TINYCLR_CHECK_HRESULT(hr);
  }
  TINYCLR_NOCLEANUP();
}

HRESULT Library_CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire::WriteBit___VOID__U1(CLR_RT_StackFrame& stack)
{
  TINYCLR_HEADER(); hr = S_OK;
  {
    CLR_RT_HeapBlock* pMngObj = Interop_Marshal_RetrieveManagedObject(stack);
    FAULT_ON_NULL(pMngObj);

    if(OneWire::Get_disposed(pMngObj))
    {
      TINYCLR_SET_AND_LEAVE(CLR_E_OBJECT_DISPOSED);
    }

    UINT8 value;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_UINT8(stack, 1, value));

    OneWire::WriteBit(pMngObj, value, hr);
    TINYCLR_CHECK_HRESULT(hr);
  }
  TINYCLR_NOCLEANUP();
}

HRESULT Library_CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire::WriteByte___VOID__U1(CLR_RT_StackFrame& stack)
{
  TINYCLR_HEADER(); hr = S_OK;
  {
    CLR_RT_HeapBlock* pMngObj = Interop_Marshal_RetrieveManagedObject(stack);
    FAULT_ON_NULL(pMngObj);

    if(OneWire::Get_disposed(pMngObj))
    {
      TINYCLR_SET_AND_LEAVE(CLR_E_OBJECT_DISPOSED);
    }

    UINT8 value;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_UINT8(stack, 1, value));

    OneWire::WriteByte(pMngObj, value, hr);
    TINYCLR_CHECK_HRESULT(hr);
  }
  TINYCLR_NOCLEANUP();
}

HRESULT Library_CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire::Search___I4__SZARRAY_U1__I4__I4(CLR_RT_StackFrame& stack)
{
  TINYCLR_HEADER(); hr = S_OK;
  {
    CLR_RT_HeapBlock* pMngObj = Interop_Marshal_RetrieveManagedObject(stack);
    FAULT_ON_NULL(pMngObj);

    if(OneWire::Get_disposed(pMngObj))
    {
      TINYCLR_SET_AND_LEAVE(CLR_E_OBJECT_DISPOSED);
    }

    CLR_RT_TypedArray_UINT8 buffer;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_UINT8_ARRAY(stack, 1, buffer));

    INT32 deviation;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_INT32(stack, 2, deviation));

    INT32 index;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_INT32(stack, 3, index));

    // Validate buffer arguments, fixed count
    INT32 count = 8;
    TINYCLR_CHECK_HRESULT(CheckBufferArguments(buffer, index, count));
    ASSERT((count == 8) && "Fixed count cannot be changed");

    INT32 retVal = OneWire::Search(pMngObj, buffer, deviation, index, hr);
    TINYCLR_CHECK_HRESULT(hr);
    SetResult_INT32(stack, retVal);
  }
  TINYCLR_NOCLEANUP();
}

HRESULT Library_CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire::ComputeCRC___STATIC__U1__SZARRAY_U1__I4__I4__U1(CLR_RT_StackFrame& stack)
{
  TINYCLR_HEADER(); hr = S_OK;
  {
    CLR_RT_TypedArray_UINT8 buffer;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_UINT8_ARRAY(stack, 0, buffer));

    INT32 index;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_INT32(stack, 1, index));

    INT32 count;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_INT32(stack, 2, count));

    // Validate buffer arguments (may change count if == -1)
    TINYCLR_CHECK_HRESULT(CheckBufferArguments(buffer, index, count));

    UINT8 crc;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_UINT8(stack, 3, crc));

    UINT8 retVal = OneWire::ComputeCRC(buffer, index, count, crc, hr);
    TINYCLR_CHECK_HRESULT(hr);
    SetResult_UINT8(stack, retVal);
  }
  TINYCLR_NOCLEANUP();
}

HRESULT Library_CW_NETMF_OneWire_CW_NETMF_Hardware_OneWire::ComputeCRC16___STATIC__U2__SZARRAY_U1__I4__I4__U2(CLR_RT_StackFrame& stack)
{
  TINYCLR_HEADER(); hr = S_OK;
  {
    CLR_RT_TypedArray_UINT8 buffer;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_UINT8_ARRAY(stack, 0, buffer));

    INT32 index;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_INT32(stack, 1, index));

    INT32 count;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_INT32(stack, 2, count));

    // Validate arguments (may change count if == -1)
    TINYCLR_CHECK_HRESULT(CheckBufferArguments(buffer, index, count));

    UINT16 crc;
    TINYCLR_CHECK_HRESULT(Interop_Marshal_UINT16(stack, 3, crc));

    UINT16 retVal = OneWire::ComputeCRC16(buffer, index, count, crc, hr);
    TINYCLR_CHECK_HRESULT(hr);
    SetResult_UINT16(stack, retVal);
  }
  TINYCLR_NOCLEANUP();
}
